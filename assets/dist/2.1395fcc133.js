"use strict";(self.webpackChunkvwww=self.webpackChunkvwww||[]).push([["2"],{55:function(e,t,n){n(4),n(8),n(13),n(36),n(38),n(22),n(12),n(6),n(9)},66:function(e,t,n){n(8),n(30),n(16),n(7)},14:function(e,t,n){n.d(t,{CF:()=>v,Cy:()=>i,YY:()=>d,_2:()=>r,eZ:()=>l,mx:()=>h,ns:()=>u,zn:()=>c});var a=n(11),s="font-weight: bold",o="font-weight: normal";function r(e){a.A?console.warn(`%c[svelte] await_reactivity_loss
%cDetected reactivity loss when reading \`${e}\`. This happens when state is read in an async function after an earlier \`await\`
https://svelte.dev/e/await_reactivity_loss`,s,o):console.warn("https://svelte.dev/e/await_reactivity_loss")}function i(e,t){a.A?console.warn(`%c[svelte] await_waterfall
%cAn async derived, \`${e}\` (${t}) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app
https://svelte.dev/e/await_waterfall`,s,o):console.warn("https://svelte.dev/e/await_waterfall")}function c(e,t,n){a.A?console.warn(`%c[svelte] hydration_attribute_changed
%cThe \`${e}\` attribute on \`${t}\` changed its value between server and client renders. The client value, \`${n}\`, will be ignored in favour of the server value
https://svelte.dev/e/hydration_attribute_changed`,s,o):console.warn("https://svelte.dev/e/hydration_attribute_changed")}function l(e){a.A?console.warn(`%c[svelte] hydration_mismatch
%c${e?`Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${e}`:"Hydration failed because the initial UI does not match what was rendered on the server"}
https://svelte.dev/e/hydration_mismatch`,s,o):console.warn("https://svelte.dev/e/hydration_mismatch")}function d(){a.A?console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`,s,o):console.warn("https://svelte.dev/e/lifecycle_double_unmount")}function u(e){a.A?console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${e}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`,s,o):console.warn("https://svelte.dev/e/state_proxy_equality_mismatch")}function h(){a.A?console.warn(`%c[svelte] state_proxy_unmount
%cTried to unmount a state proxy, rather than a component
https://svelte.dev/e/state_proxy_unmount`,s,o):console.warn("https://svelte.dev/e/state_proxy_unmount")}function v(){a.A?console.warn("%c[svelte] svelte_boundary_reset_noop\n%cA `<svelte:boundary>` `reset` function only resets the boundary the first time it is called\nhttps://svelte.dev/e/svelte_boundary_reset_noop",s,o):console.warn("https://svelte.dev/e/svelte_boundary_reset_noop")}},38:function(e,t,n){n.d(t,{GY:()=>s});let a=["touchstart","touchmove"];function s(e){return a.includes(e)}}}]);