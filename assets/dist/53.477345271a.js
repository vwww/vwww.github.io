"use strict";(self.webpackChunkvwww=self.webpackChunkvwww||[]).push([["53"],{59(e,t,n){n.d(t,{q:()=>f});var a=n(4),o=n(9),r=n(13),s=n(41),l=n(40),i=n(14),c=n(42),d=n(7),h=n(23),u=n(12),v=n(6);function f(e,t,n=!1,w=!1,_=!1){var m=e,p="";(0,o.vN)(()=>{var e=v.Fg;if(p===(p=t()??"")){r.fE&&(0,r.E$)();return}if(null!==e.nodes&&((0,o.mk)(e.nodes.start,e.nodes.end),e.nodes=null),""!==p){if(r.fE){for(var f=r.Xb.data,y=(0,r.E$)(),b=y;null!==y&&(8!==y.nodeType||""!==y.data);)b=y,y=(0,u.M$)(y);if(null===y)throw i.eZ(),a.kD;d.A&&!_&&function(e,t,n){let o;if(!t||t===(0,c.tW)(String(n??"")))return;let r=e.__svelte_meta?.loc;r?o=`near ${r.file}:${r.line}:${r.column}`:h.DE?.[a.Uh]&&(o=`in ${h.DE[a.Uh]}`),i.Y9((0,c.If)(o))}(y.parentNode,f,p),(0,l.mX)(r.Xb,b),m=(0,r.W0)(y);return}var g=p+"";n?g=`<svg>${g}</svg>`:w&&(g=`<math>${g}</math>`);var $=(0,s.L)(g);if((n||w)&&($=(0,u.Zj)($)),(0,l.mX)((0,u.Zj)($),$.lastChild),n||w)for(;(0,u.Zj)($);)m.before((0,u.Zj)($));else m.before($)}})}n(10)},14(e,t,n){n.d(t,{CF:()=>v,Cy:()=>s,Y9:()=>i,YY:()=>d,eZ:()=>c,mx:()=>u,ns:()=>h,zn:()=>l});var a=n(7),o="font-weight: bold",r="font-weight: normal";function s(e,t){a.A?console.warn(`%c[svelte] await_waterfall
%cAn async derived, \`${e}\` (${t}) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app
https://svelte.dev/e/await_waterfall`,o,r):console.warn("https://svelte.dev/e/await_waterfall")}function l(e,t,n){a.A?console.warn(`%c[svelte] hydration_attribute_changed
%cThe \`${e}\` attribute on \`${t}\` changed its value between server and client renders. The client value, \`${n}\`, will be ignored in favour of the server value
https://svelte.dev/e/hydration_attribute_changed`,o,r):console.warn("https://svelte.dev/e/hydration_attribute_changed")}function i(e){a.A?console.warn(`%c[svelte] hydration_html_changed
%c${e?`The value of an \`{@html ...}\` block ${e} changed between server and client renders. The client value will be ignored in favour of the server value`:"The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value"}
https://svelte.dev/e/hydration_html_changed`,o,r):console.warn("https://svelte.dev/e/hydration_html_changed")}function c(e){a.A?console.warn(`%c[svelte] hydration_mismatch
%c${e?`Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${e}`:"Hydration failed because the initial UI does not match what was rendered on the server"}
https://svelte.dev/e/hydration_mismatch`,o,r):console.warn("https://svelte.dev/e/hydration_mismatch")}function d(){a.A?console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`,o,r):console.warn("https://svelte.dev/e/lifecycle_double_unmount")}function h(e){a.A?console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${e}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`,o,r):console.warn("https://svelte.dev/e/state_proxy_equality_mismatch")}function u(){a.A?console.warn(`%c[svelte] state_proxy_unmount
%cTried to unmount a state proxy, rather than a component
https://svelte.dev/e/state_proxy_unmount`,o,r):console.warn("https://svelte.dev/e/state_proxy_unmount")}function v(){a.A?console.warn("%c[svelte] svelte_boundary_reset_noop\n%cA `<svelte:boundary>` `reset` function only resets the boundary the first time it is called\nhttps://svelte.dev/e/svelte_boundary_reset_noop",o,r):console.warn("https://svelte.dev/e/svelte_boundary_reset_noop")}},42(e,t,n){n.d(t,{GY:()=>s,If:()=>l,tW:()=>o});let a=/\r/g;function o(e){e=e.replace(a,"");let t=5381,n=e.length;for(;n--;)t=(t<<5)-t^e.charCodeAt(n);return(t>>>0).toString(36)}let r=["touchstart","touchmove"];function s(e){return r.includes(e)}function l(e){return e?.replace(/\//g,"/â€‹")}}}]);